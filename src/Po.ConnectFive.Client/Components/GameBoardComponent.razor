@namespace PoConnectFive.Client.Components
@using PoConnectFive.Shared.Models
@using Microsoft.JSInterop
@inject IJSRuntime JSRuntime

<div class="game-board" @ref="boardElementReference" tabindex="0" @onkeydown="OnKeyDown" role="grid"
    aria-label="Connect Five Game Board" aria-describedby="game-instructions">
    <canvas id="gameCanvas" @ref="canvasReference" width="@(_boardWidth)" height="@(_boardHeight)"
        @onclick="OnCanvasClick" @onmousemove="OnCanvasMouseMove" @onmouseleave="OnCanvasMouseLeave"></canvas>
    <div id="game-instructions" class="sr-only">
        Use arrow keys to navigate between columns. Press Enter or Space to place a piece. Press Escape to return focus
        to the menu.
    </div>
    <div id="game-status" role="status" aria-live="polite" aria-atomic="true" class="sr-only">
        @_screenReaderStatus
    </div>
</div>

@code {
    [Parameter]
    public GameBoard? Board { get; set; }

    [Parameter]
    public GameState? CurrentState { get; set; }

    [Parameter]
    public EventCallback<int> OnColumnClicked { get; set; }

    [Parameter]
    public EventCallback OnAnimationComplete { get; set; }

    private ElementReference boardElementReference;
    private ElementReference canvasReference;
    private DotNetObjectReference<GameBoardComponent>? objRef;
    private int _boardWidth = 700; // Default width
    private int _boardHeight = 600; // Default height
    private GameBoardViewModel? _viewModel;
    private int _selectedColumn = 4; // Default to center column
    private string _screenReaderStatus = "";
    private bool _isInitialized = false;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Get viewport width for responsive sizing
                var windowWidth = await JSRuntime.InvokeAsync<int>("eval", "window.innerWidth");

                // Adjust board size based on screen width
                if (windowWidth < 576)
                {
                    // Mobile portrait - use 90% of viewport width
                    _boardWidth = (int)(windowWidth * 0.9);
                    _boardHeight = (int)(_boardWidth * 0.85); // Slightly taller ratio
                }
                else if (windowWidth < 768)
                {
                    // Small tablet
                    _boardWidth = Math.Min(500, (int)(windowWidth * 0.8));
                    _boardHeight = (int)(_boardWidth * 0.85);
                }
                else
                {
                    // Desktop - use default size
                    _boardWidth = 700;
                    _boardHeight = 600;
                }

                // Trigger re-render with new dimensions
                StateHasChanged();

                objRef = DotNetObjectReference.Create(this);
                // Create view-model which centralizes cell size & mapping logic
                _viewModel = new GameBoardViewModel(GameBoard.Rows, GameBoard.Columns, _boardWidth, _boardHeight);

                // Pass canvas dimensions and cell size to JS for consistent rendering.
                await JSRuntime.InvokeVoidAsync("gameBoardInterop.initialize",
                canvasReference,
                objRef,
                GameBoard.Rows,
                GameBoard.Columns,
                _boardWidth,
                _boardHeight,
                _viewModel.CellSize,
                _viewModel.Inset);

                // Focus the board for keyboard navigation
                await JSRuntime.InvokeVoidAsync("setTimeout",
                DotNetObjectReference.Create(new FocusHelper(JSRuntime, boardElementReference)), 100);

                _isInitialized = true;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing game board: {ex.Message}");
            }
        }

        if (_isInitialized && Board != null && CurrentState != null)
        {
            var boardData = Board.GetBoard();
            if (boardData != null)
            {
                await JSRuntime.InvokeVoidAsync("gameBoardInterop.updateBoard", boardData, CurrentState.Status);
            }
        }
    }

    [JSInvokable]
    public async Task OnColumnClickedFromJS(int column)
    {
        await OnColumnClicked.InvokeAsync(column);
    }

    [JSInvokable]
    public async Task OnAnimationCompleteFromJS()
    {
        await OnAnimationComplete.InvokeAsync();
    }

    private async Task OnCanvasClick(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        if (_viewModel == null) return;

        // Get canvas left offset from JS to compute local X reliably
        var canvasRect = await JSRuntime.InvokeAsync<DOMRect>("gameBoardInterop.getCanvasRect", canvasReference);
        double localX = e.ClientX - canvasRect.left;
        int column = _viewModel.MapClientXToColumn(localX);
        if (column >= 0)
        {
            await OnColumnClicked.InvokeAsync(column);
        }
    }

    private async Task OnCanvasMouseMove(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        if (_viewModel == null) return;
        var canvasRect = await JSRuntime.InvokeAsync<DOMRect>("gameBoardInterop.getCanvasRect", canvasReference);
        double localX = e.ClientX - canvasRect.left;
        int column = _viewModel.MapClientXToColumn(localX);
        if (column >= 0)
        {
            // request JS to show preview at this column
            await JSRuntime.InvokeVoidAsync("gameBoardInterop.showPreview", column);
        }
    }

    private async Task OnCanvasMouseLeave(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        await JSRuntime.InvokeVoidAsync("gameBoardInterop.clearPreview");
    }

    private async Task OnKeyDown(Microsoft.AspNetCore.Components.Web.KeyboardEventArgs e)
    {
        if (CurrentState?.Status != GameStatus.InProgress) return;

        switch (e.Key)
        {
            case "ArrowLeft":
                _selectedColumn = Math.Max(0, _selectedColumn - 1);
                await ShowKeyboardPreview();
                await AnnounceColumn();
                break;

            case "ArrowRight":
                _selectedColumn = Math.Min(GameBoard.Columns - 1, _selectedColumn + 1);
                await ShowKeyboardPreview();
                await AnnounceColumn();
                break;

            case "Home":
                _selectedColumn = 0;
                await ShowKeyboardPreview();
                await AnnounceColumn();
                break;

            case "End":
                _selectedColumn = GameBoard.Columns - 1;
                await ShowKeyboardPreview();
                await AnnounceColumn();
                break;

            case "Enter":
            case " ":
                if (Board?.IsValidMove(_selectedColumn) == true)
                {
                    await OnColumnClicked.InvokeAsync(_selectedColumn);
                    _screenReaderStatus = $"Piece placed in column {_selectedColumn + 1}";
                    StateHasChanged();
                }
                break;

            case "Escape":
                await JSRuntime.InvokeVoidAsync("gameBoardInterop.clearPreview");
                break;
        }
    }

    private async Task ShowKeyboardPreview()
    {
        if (_viewModel != null)
        {
            await JSRuntime.InvokeVoidAsync("gameBoardInterop.showPreview", _selectedColumn);
        }
    }

    private Task AnnounceColumn()
    {
        _screenReaderStatus = $"Column {_selectedColumn + 1} selected";
        StateHasChanged();
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (objRef != null)
            {
                objRef.Dispose();
            }
            await JSRuntime.InvokeVoidAsync("gameBoardInterop.dispose");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during disposal: {ex.Message}");
        }
    }

    // Minimal DOMRect proxy for JS interop calls
    public class DOMRect
    {
        public double left { get; set; }
        public double top { get; set; }
        public double right { get; set; }
        public double bottom { get; set; }
        public double width { get; set; }
        public double height { get; set; }
    }

    // Helper class for focusing element after render
    private class FocusHelper
    {
        private readonly IJSRuntime _js;
        private readonly ElementReference _element;

        public FocusHelper(IJSRuntime js, ElementReference element)
        {
            _js = js;
            _element = element;
        }

        [JSInvokable]
        public async Task FocusElement()
        {
            try
            {
                await _js.InvokeVoidAsync("eval", $"arguments[0].focus()", _element);
            }
            catch { }
        }
    }
}