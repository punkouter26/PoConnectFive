classDiagram
    class GameBoard {
        -int[][] _board
        +const int Rows = 9
        +const int Columns = 9
        +const int WinLength = 5
        +GameBoard()
        +int[][] GetBoard()
        +bool IsValidMove(int column)
        +int GetTargetRow(int column)
        +GameBoard PlacePiece(int column, int playerId)
        +bool CheckWin(int row, int column, int playerId)
        +bool HasValidMoves()
        +int this[int row, int column]
        +int GetCell(int row, int column)
        +GameBoard CloneWithMove(int column, int playerId)
        +string ToString()
    }

    class GameState {
        +GameBoard Board
        +Player Player1
        +Player Player2
        +Player CurrentPlayer
        +GameStatus Status
        +int? WinningMove
        +GameState(board, player1, player2, currentPlayer, status, winningMove)
        +static GameState CreateNew(player1, player2)$
    }

    class Player {
        +int Id
        +string Name
        +PlayerType Type
        +Player(id, name, type)
    }

    class PlayerStatEntity {
        +string PartitionKey
        +string RowKey
        +string PlayerName
        +AIDifficulty Difficulty
        +int Wins
        +int Losses
        +int Draws
        +long TotalGameTimeSeconds
        +DateTime Timestamp
        +double WinPercentage
        +PlayerStatEntity()
        +PlayerStatEntity(playerName, difficulty)
    }

    class PlayerStatUpdateDto {
        +string PlayerName
        +AIDifficulty Difficulty
        +GameResult Result
        +long GameTimeMilliseconds
    }

    class GameStatus {
        <<enumeration>>
        InProgress
        Player1Won
        Player2Won
        Draw
    }

    class PlayerType {
        <<enumeration>>
        Human
        AI
    }

    class AIDifficulty {
        <<enumeration>>
        Easy
        Medium
        Hard
    }

    class GameResult {
        <<enumeration>>
        Win
        Loss
        Draw
    }

    class IAIPlayer {
        <<interface>>
        +Task~int~ GetNextMove(GameState gameState)
    }

    class EasyAIPlayer {
        +Task~int~ GetNextMove(GameState gameState)
    }

    class MediumAIPlayer {
        +Task~int~ GetNextMove(GameState gameState)
    }

    class HardAIPlayer {
        -IBoardEvaluator _boardEvaluator
        -const int MaxDepth = 4
        +HardAIPlayer(boardEvaluator)
        +Task~int~ GetNextMove(GameState gameState)
        -int Minimax(board, depth, isMaximizing, alpha, beta, playerId)
    }

    class IBoardEvaluator {
        <<interface>>
        +int EvaluateBoard(GameBoard board, int playerId)
    }

    class BoardEvaluator {
        +int EvaluateBoard(GameBoard board, int playerId)
        -int EvaluateLine(cells, playerId)
        -int CountConsecutive(cells, playerId)
    }

    %% Relationships
    GameState --> GameBoard : contains
    GameState --> Player : has 2
    GameState --> GameStatus : uses
    Player --> PlayerType : has
    PlayerStatEntity --> AIDifficulty : categorized by
    PlayerStatUpdateDto --> AIDifficulty : uses
    PlayerStatUpdateDto --> GameResult : uses

    IAIPlayer <|.. EasyAIPlayer : implements
    IAIPlayer <|.. MediumAIPlayer : implements
    IAIPlayer <|.. HardAIPlayer : implements
    HardAIPlayer --> IBoardEvaluator : uses
    IBoardEvaluator <|.. BoardEvaluator : implements

    note for GameBoard "Immutable state management\nValue Object Pattern\nMemento Pattern"
    note for GameState "State Pattern for game flow\nFactory Pattern for creation"
    note for HardAIPlayer "Uses Minimax algorithm\nwith alpha-beta pruning"
