@namespace PoConnectFive.Client.Components
@using PoConnectFive.Shared.Models
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JSRuntime

<div class="game-board-container">
    <div class="game-board @(_isDragging ? "dragging" : "")"
         @onmousemove="HandleMouseMove"
         @onmouseleave="HandleMouseLeave"
         @ontouchstart="HandleTouchStart"
         @ontouchmove="HandleTouchMove"
         @ontouchend="HandleTouchEnd">
        
        <canvas @ref="canvasReference" 
                @onclick="HandleClick"
                width="@(CellSize * GameBoard.Columns)" 
                height="@(CellSize * GameBoard.Rows)">
        </canvas>

        @if (_currentColumn.HasValue)
        {
            <div class="preview-piece"
                 style="left: @(_currentColumn.Value * CellSize)px">
            </div>
        }

        @if (_isAnimating)
        {
            <div class="piece-animation"
                 style="left: @(_animationColumn * CellSize)px;
                        top: @(_animationStartRow * CellSize)px;
                        animation-duration: @(_animationDuration)ms;
                        color: @(CurrentState?.CurrentPlayer.Id == 1 ? "#FF0000" : "#FFFF00");
                        --target-row-offset: @(_animationTargetRow * CellSize)px;">
            </div>
        }

        @if (_isWinningAnimation)
        {
            <div class="winning-animation"
                 style="--winning-pieces: @(_winningPiecesJson)">
            </div>
        }
    </div>
</div>

@code {
    private ElementReference canvasReference;
    private const int CellSize = 40;
    private const int PieceRadius = 15;
    private int? _currentColumn;
    private bool _isDragging;
    private bool _isAnimating;
    private int _animationColumn;
    private int _animationStartRow;
    private int _animationTargetRow;
    private const int _animationDuration = 300;
    private bool _isWinningAnimation;
    private string _winningPiecesJson = string.Empty;

    [Parameter]
    public GameBoard Board { get; set; } = default!;

    [Parameter]
    public EventCallback<int> OnColumnClicked { get; set; }

    [Parameter]
    public GameState? CurrentState { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await DrawBoardAsync();
    }

    private async Task DrawBoardAsync()
    {
        try
        {
            var rows = GameBoard.Rows;
            var cols = GameBoard.Columns;
            var boardState = new int[rows][];
            
            for (int i = 0; i < rows; i++)
            {
                boardState[i] = new int[cols];
                for (int j = 0; j < cols; j++)
                {
                    boardState[i][j] = Board.GetCell(i, j);
                }
            }

            var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/gameBoard.js");
            await module.InvokeVoidAsync("drawBoard", canvasReference, new { cells = boardState }, CellSize, PieceRadius, _currentColumn);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading JS module: {ex.Message}");
        }
    }

    public async Task AnimatePieceDrop(int column)
    {
        _animationColumn = column;
        _animationStartRow = -1;
        _animationTargetRow = Board.GetTargetRow(column);
        _isAnimating = true;
        StateHasChanged();

        await Task.Delay(_animationDuration);
        _isAnimating = false;
        StateHasChanged();
    }

    public async Task AnimateWin(List<(int row, int col)> winningPieces)
    {
        _winningPiecesJson = System.Text.Json.JsonSerializer.Serialize(winningPieces);
        _isWinningAnimation = true;
        StateHasChanged();

        await Task.Delay(2000); // Duration of winning animation
        _isWinningAnimation = false;
        StateHasChanged();
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        var column = GetColumnFromX(e.OffsetX);
        if (column >= 0 && column < GameBoard.Columns && Board.IsValidMove(column))
        {
            await AnimatePieceDrop(column);
            await OnColumnClicked.InvokeAsync(column);
        }
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        _currentColumn = GetColumnFromX(e.OffsetX);
        StateHasChanged();
    }

    private void HandleMouseLeave()
    {
        _currentColumn = null;
        _isDragging = false;
        StateHasChanged();
    }

    private int GetColumnFromX(double x)
    {
        return (int)(x / CellSize);
    }

    private void HandleTouchStart(TouchEventArgs e)
    {
        _isDragging = true;
        _ = HandleTouchMove(e);  // Fire and forget
    }

    private async Task HandleTouchMove(TouchEventArgs e)
    {
        if (!_isDragging) return;

        var touch = e.Touches[0];
        var rect = await GetBoundingClientRect();
        var x = touch.ClientX - rect.Left;
        _currentColumn = GetColumnFromX(x);
        StateHasChanged();
    }

    private async Task HandleTouchEnd(TouchEventArgs e)
    {
        if (!_isDragging) return;

        _isDragging = false;
        if (_currentColumn.HasValue)
        {
            await HandleClick(new MouseEventArgs { OffsetX = _currentColumn.Value * CellSize });
        }
        _currentColumn = null;
        StateHasChanged();
    }

    private async Task<DOMRect> GetBoundingClientRect()
    {
        var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/gameBoard.js");
        return await module.InvokeAsync<DOMRect>("getBoundingClientRect", canvasReference);
    }

    private class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .game-board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px;
        touch-action: none;
    }

    .game-board {
        position: relative;
        border: 2px solid #333;
        background-color: #2196F3;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    canvas {
        display: block;
    }

    .preview-piece {
        position: absolute;
        top: -@(CellSize)px;
        width: @(CellSize)px;
        height: @(CellSize)px;
        pointer-events: none;
        transition: left 0.1s ease;
    }

    .preview-piece::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: @(PieceRadius * 2)px;
        height: @(PieceRadius * 2)px;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .piece-animation {
        position: absolute;
        width: @(CellSize)px;
        height: @(CellSize)px;
        pointer-events: none;
        animation: dropPiece @(_animationDuration)ms cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }

    .piece-animation::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: @(PieceRadius * 2)px;
        height: @(PieceRadius * 2)px;
        background-color: currentColor;
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .winning-animation {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        animation: pulseWinning 2s ease-in-out infinite;
    }

    @@keyframes dropPiece {
        0% {
            transform: translateY(0);
        }
        100% {
            transform: translateY(var(--target-row-offset));
        }
    }

    @@keyframes pulseWinning {
        0% {
            box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.4);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(255, 255, 0, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(255, 255, 0, 0);
        }
    }
</style>
