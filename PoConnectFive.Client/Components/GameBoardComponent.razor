@namespace PoConnectFive.Client.Components
@using PoConnectFive.Shared.Models
@using Microsoft.AspNetCore.Components.Web
@inject IJSRuntime JSRuntime

<div class="game-board-container">
    <div class="game-board @(_isDragging ? "dragging" : "")"
         @onmousemove="HandleMouseMove"
         @onmouseleave="HandleMouseLeave"
         @ontouchstart="HandleTouchStart"
         @ontouchmove="HandleTouchMove"
         @ontouchend="HandleTouchEnd">
        
        <canvas @ref="canvasReference" 
                @onclick="HandleClick"
                width="@(CellSize * GameBoard.Columns)" 
                height="@(CellSize * GameBoard.Rows)">
        </canvas>

        @if (_currentColumn.HasValue)
        {
            <div class="preview-piece"
                 style="left: @(_currentColumn.Value * CellSize)px">
            </div>
        }

        @if (_isAnimating)
        {
             <div class="piece-animation"
                  style="left: @(_animationColumn * CellSize)px;
                         top: @(_animationStartRow * CellSize)px;
                         animation-duration: @(_animationDuration)ms;
                         color: @(CurrentState?.CurrentPlayer.Id == 1 ? "#FF0000" : "#FFFF00");
                         --target-row-offset: @(_animationTargetRow * CellSize)px;">
            </div>
        }
    </div>
</div>

@code {
    private ElementReference canvasReference;
    private const int CellSize = 40;
    private const int PieceRadius = 15;
    private int? _currentColumn;
    private bool _isDragging;
    private bool _isAnimating;
    private int _animationColumn;
    private int _animationStartRow;
    private int _animationTargetRow; // Added to store the calculated target row
    private const int _animationDuration = 300; // ms

    [Parameter]
    public GameBoard Board { get; set; } = default!;

    [Parameter]
    public EventCallback<int> OnColumnClicked { get; set; }

    [Parameter]
    public GameState? CurrentState { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await DrawBoardAsync();
    }

    private async Task DrawBoardAsync()
    {
        try
        {
            // Convert the 2D array to a jagged array for proper serialization
            var rows = GameBoard.Rows;
            var cols = GameBoard.Columns;
            var boardState = new int[rows][];
            
            for (int i = 0; i < rows; i++)
            {
                boardState[i] = new int[cols];
                for (int j = 0; j < cols; j++)
                {
                    boardState[i][j] = Board.GetCell(i, j);
                }
            }

            var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/gameBoard.js");
            await module.InvokeVoidAsync("drawBoard", canvasReference, new { cells = boardState }, CellSize, PieceRadius, _currentColumn);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading JS module: {ex.Message}");
        }
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        var column = GetColumnFromX(e.OffsetX);
        if (column >= 0 && column < GameBoard.Columns && Board.IsValidMove(column))
        {
            await AnimatePieceDrop(column);
            await OnColumnClicked.InvokeAsync(column);
            await PlaySoundEffect("pieceDrop");
        }
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        _currentColumn = GetColumnFromX(e.OffsetX);
        StateHasChanged();
    }

    private void HandleMouseLeave()
    {
        _currentColumn = null;
        _isDragging = false;
        StateHasChanged();
    }

    private void HandleTouchStart(TouchEventArgs e)
    {
        _isDragging = true;
        UpdateTouchPosition(e);
    }

    private void HandleTouchMove(TouchEventArgs e)
    {
        if (_isDragging)
        {
            UpdateTouchPosition(e);
        }
    }

    private async Task HandleTouchEnd(TouchEventArgs e)
    {
        if (_isDragging && _currentColumn.HasValue)
        {
            var column = _currentColumn.Value;
            if (Board.IsValidMove(column))
            {
                await AnimatePieceDrop(column);
                await OnColumnClicked.InvokeAsync(column);
                await PlaySoundEffect("pieceDrop");
            }
        }
        _isDragging = false;
        _currentColumn = null;
        StateHasChanged();
    }

    private async Task UpdateTouchPosition(TouchEventArgs e)
    {
        var touch = e.Touches[0];
        var rect = await JSRuntime.InvokeAsync<DOMRect>("getBoundingClientRect", canvasReference);
        var x = touch.ClientX - rect.Left;
        _currentColumn = GetColumnFromX(x);
        StateHasChanged();
    }

    private int GetColumnFromX(double x)
    {
        return (int)(x / CellSize);
    }

    public async Task AnimatePieceDrop(int column)
    {
        _animationTargetRow = Board.GetTargetRow(column);
        if (_animationTargetRow == -1) return; // Column is full, don't animate

        _isAnimating = true;
        _animationColumn = column;
        _animationStartRow = 0; // Animation always starts from the top visually
        StateHasChanged();

        await Task.Delay(_animationDuration);
        _isAnimating = false;
        StateHasChanged();
    }

    private async Task PlaySoundEffect(string sound)
    {
        var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/gameBoard.js");
        await module.InvokeVoidAsync("playSoundEffect", sound);
    }

    private class DOMRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
    }
}

<style>
    .game-board-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 20px;
        touch-action: none; /* Prevent scrolling on touch devices */
    }

    .game-board {
        position: relative;
        border: 2px solid #333;
        background-color: #2196F3;
        border-radius: 8px;
        overflow: hidden;
    }

    canvas {
        display: block;
    }

    .preview-piece {
        position: absolute;
        top: -@(CellSize)px;
        width: @(CellSize)px;
        height: @(CellSize)px;
        pointer-events: none;
        transition: left 0.1s ease;
    }

    .preview-piece::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: @(PieceRadius * 2)px;
        height: @(PieceRadius * 2)px;
        background-color: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
    }

    .piece-animation {
        position: absolute;
        width: @(CellSize)px;
        height: @(CellSize)px;
        pointer-events: none;
        animation: dropPiece @(_animationDuration)ms cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }

    .piece-animation::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: @(PieceRadius * 2)px;
        height: @(PieceRadius * 2)px;
        background-color: currentColor;
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    @@keyframes dropPiece {
        0% {
            transform: translateY(0);
        }
        /* Animate slightly past the target row for a small bounce effect */
        70% { 
            transform: translateY(calc(var(--target-row-offset) + @(CellSize * 0.2)px)); 
        }
        /* Bounce back up slightly */
        85% { 
            transform: translateY(calc(var(--target-row-offset) - @(CellSize * 0.1)px)); 
        }
        /* Settle at the final target row */
        100% {
            transform: translateY(var(--target-row-offset));
        }
    }
</style>
